### 1 Аргументы, передаваемые функции по умолчанию

В C++ мы можем придать параметру некоторое значение, которое будет автоматически использовано, если при вызове функции не задается аргумент, соответствующий этому параметру. Аргументы, передаваемые функции по умолчанию, можно использовать, чтобы упростить обращение к сложным функциям, а также в качестве "сокращенной формы" перегрузки функций.

 ```cpp
 void myfunc(double num = 0.0, char ch = 'Х')
{
    ///
}
```

После такого объявления функцию myfunc() можно вызвать одним из трех следующих способов.

```cpp
myFunc(198.234, 'A'); // Передаем явно заданные значения.
 ```

```cpp
myfunc(10.1); // Передаем для параметра num значение 10.1, а для параметра ch позволяем применить аргумент, задаваемый по умолчанию ('Х').
 ```

```cpp
myfunc(); // Для обоих параметров num и ch позволяем применить аргументы, задаваемые по умолчанию.
```

При первом вызове параметру num передается значение `198.234`, а параметру `ch` — символ `'А'`. Во время второго вызова параметру num передается значение `10.1`, а параметр `ch` по умолчанию устанавливается равным символу `'Х'`. Наконец, в результате третьего вызова как параметр `num`, так и параметр `ch` по умолчанию устанавливаются равными значениям, заданным в объявлении функции.

**Аргумент**, передаваемый функции **по умолчанию**, представляет собой значение, которое будет автоматически передано параметру функции в случае, если аргумент, соответствующий этому параметру, явным образом не задан.

### 2. Архитектура системы. Иерархия объектов

![untitled](/assets/screenshot_5.png)

Архитектура системы так или иначе строится путем создания иерархии объектов и взаимодействия между объектами.

Наследование поддерживает иерархические отношения между классами – is a. Основой выявления таких отношений, является исследование задачи, проведение классификации выявленных сущностей – классов, определения их общих свойств и поведения. На верхний уровень иерархии выносятся свойства и операции общие для всех сущностей, далее уровни выстраиваются по такому же принципу.

![untitled](/assets/screenshot_3.png)

### 3. Ввод-вывод в С++. Потоки

Текстовый поток — это последовательность символов, к которым можно получить доступ. Со временем поток может производить или потреблять потенциально неограниченные объемы данных.

В C++ для ввода и вывода используются потоки `cin` и `cout`.

### 4. В чем различие между ссылкой и указателем?

![untitled](/assets/screenshot_9.png)
![untitled](/assets/screenshot_10.png)

Чтобы использовать свойства и методы через указатель на объект, необходимо использовать `->` вместо `.`

```cpp
class MyClass {
public:
  void foo();
};

int main() {
  MyClass obj;
  MyClass obj_ptr = &obj;
  obj_ptr->foo();
}
```

В Visual C++ (CLR – Common Language Runtime) поддерживаются три типа указателей:

- управляемые указатели (managed pointers);
- неуправляемые указатели (unmanaged pointers);
- неуправляемые указатели на функции (unmanaged function pointers).

Отличие между управляемыми и неуправляемыми указателями состоит в следующем: в отличие от управляемого указателя неуправляемому указателю можно присвоить любой адрес памяти, даже той, которая находится за пределами исполнительной среды. В этом случае память является **нерегулируемой**.

 В случае **регулируемой** памяти управляемому указателю присвоить адрес за пределами исполнительной среды не удастся.

 **Управляемые указатели** – это указатели ссылочного типа. Эти указатели передаются для аргументов, методов, которые передаются по ссылке.

Управляемые указатели являются ссылками на объекты. Эти объекты
размещаются в общей управляемой памяти, которая выделяется для программы в момент ее выполнения.

В таких указателях вместо символа ‘*’ применяется символ ‘^’. Для
выделения.

**Неуправляемые указатели** (unmanaged pointer) – это традиционные
указатели C/C++. Они являются указателями на объекты в неуправляемом
объеме памяти, которая выделяется для выполнения программы.
Неуправляемые указатели не являются совместимыми со спецификацией CLR.

**Неуправляемые указатели на функции** – это указатели на функции,
которые можно обрабатывать таким же образом, как и неуправляемые
указатели на объекты (данные).

Чтобы использовать свойства и методы через указатель на объект, необходимо использовать -> вместо.

### 5. Виртуальные базовые классы

При множественном наследовании может возникнуть неоднозначность.

В качестве примера, рассмотрим следующую задачу. Класс ChildClass является наследником классов ParentClass1 и ParentClass2.

```cpp
class BaseClass {
public:
  int num;
};

class ParentClass1 : public BaseClass{
  
};

class ParentClass2 : public BaseClass{
  
};

class ChildClass : public ParentClass1, public  ParentClass2 {
};

int main() {
   ChildClass obj;
   obj.num = 1;
   // Ошибка! неявное имя переменной
   return 0;
}
```

Программу можно исправить двумя способами:

1. Применить оператор разрешения области видимости `::` к переменной num

```cpp
class BaseClass {
public:
  int num;
};

class ParentClass1 : public BaseClass{
  
};

class ParentClass2 : public BaseClass{
  
};

class ChildClass : public ParentClass1, public  ParentClass2 {
};

int main() {
   ChildClass obj;
   obj.ParentClass1::num = 1;
   return 0;
}
```

Оператор разрешения области видимости `::` позволяет явно выбрать вариант производного класса. Однако данный способ решения порождает проблемы: Что если на самом деле нужна лишь одна копия объекта, можно ли предот­вратить дублирование объектов?

1. Использование виртуальных базовых классов

```cpp
class BaseClass {
public:
  int num;
};

class ParentClass1 : virtual public BaseClass {
  
};

class ParentClass2 : virtual public BaseClass {
  
};

class ChildClass : public ParentClass1, public  ParentClass2 {
};

int main() {
   ChildClass obj;
   obj.num = 1;
   return 0;
}
```

Как видим, перед именем базового класса в спецификации производного класса стоит ключевое слово `virtual`.

Теперь оба класса являются наследниками виртуального базового класса `BaseClass`, и любые их наследники будут со­ держать лишь одну его копию. Следовательно, выражение `obj.num = 1` становится однозначным

### 6. Взаимодействие объектов. Три примера взаимодействия объектов

При использовании технологи ООП решение задачи представляется в виде результата **взаимодействия** отдельных функциональных элементов (объектов/экземпляров) некоторой системы, происходящие в предметной области поставленной задачи.

В такой системе, каждый входящий функциональный элемент, получив некоторое входное воздействие (сообщение), выполняет заранее определенное действие.

Например, он может:

- опустить монету в автомат по продаже газет;
- нарисовать круг или квадрат;
- вычислить их площадь или периметр;
  
т.е. он воздействует на себя или на другой объект, изменяя состояние себя или другого элемента. Передавая сообщения, от элемента к элементу, система выполняет определенные действия.

![untitled](/assets/screenshot_2.png)

### 7. Виртуальные методы. Наследование виртуальных методов

Виртуальная функция — функция-член, объявленная в базовом классе и переопределенная в производном.

Чтобы создать виртуальную функ­цию, следует указать ключевое слово `virtual` перед ее объявлением в базовом классе.

По существу, виртуальная функция реализует принцип “один интер­фейс, несколько методов”, лежащий в основе полиморфизма.

При наследовании виртуальной функции ее виртуальная природа также наследует­ся.

Виртуальные функции являются иерархическими.

Виртуальную функцию не обязательно определять в классе наследнике. В этом случае вызывается функция, определенная в базовом классе.

### 8. В чем отличие между классом и структурой?

В `С++` основная разница между структурой и классом - это модификатор доступа, который используется по умолчанию для их членов. Для классов, по умолчанию используется модификатор `private`, а для структур - `public`.

### 9. Встраиваемая функция

В ООП при разработке классов создается много маленьких функций, это порождает много вызовов, что затратно по времени. В С++ преодолеть эту трудность помогают функции - подстановки (inline).

Такие функции можно определить в классе, а можно объявить в классе как обычную функцию – член, а реализовать вне класса как функцию inline.

Тела функций встраиваются в код на месте вызова этой функции при выполнении препроцессорной обработки

```cpp
inline void foo() {
  // тело функции
}
```

### 10.  Для чего используется ключевое слово protected?

Модификатор доступа `protected` (защищённый) разрешает доступ самому классу, наследующим его классам и родительским классам.

### 11.  Дружественная функция

**Дружественная функция** не является членом класса, но получает доступ к закрытым элементам объекта класса.

Методы класса используются для реализации свойств объекта. В виде
дружественных функции оформляются действия, не представляющие свойства класса, но концептуально входящие в состав класса и нуждающиеся в доступе к его скрытым полям, например, переопределение операции вывода объекта в поток вывода.

Правила использования:

- Объявляется внутри функции при помощи ключевого слова `friend`.
- В качестве параметра ей должен передаваться объект, ссылка или
указатель на объект, так как указатель `this` ей не доступен.
- Дружественная функция может быть внешней функцией или методом
другого класса.
- Определение дружественной функции осуществляется вне класса,
действие спецификатора доступа на нее не распространяется.

Обычно дружественные функции используются для перегрузки операторов или имеют вспомогательное назначение — например, вывод.

```cpp
friend void foo();
```

### 12.  Дружественный класс

Класс можно объявить дружественным по отношению к другому классу при ключевого слова `friend`. В таком случае в классе можно будет получить доступ к приватным и защищённым свойствам и методам другого класса.

```cpp
class MyClass1 {
friend class MyClass2;
}
```

### 12.  Защищенные члены класса

Если необходимо защитить член класса от доступа извне, но позволить использовать его производным классам, используется другое ключевое слово — protected (защищенный). Если продолжить аналогию, это напоминает семейную ценность, передаваемую по наследству.

Защищен­ный член подобен частному, за исключением механизма наследования. При наследовании защищенного члена производный класс также имеет к нему доступ. Таким образом, указав специфи­катор доступа protected, можно позволить использовать атрибуты и методы внутри иерархии и запретить доступ к нему извне этой иерархии.

```cpp
class MyClass {
protected:
  //защищенные члены класса
};
```

### 14. Жизненный цикл объекта.

![untitled](/assets/screenshot_1.png)

### 15. Жизненный цикл виртуального объекта и его реализация на языке С++

![untitled](/assets/screenshot_11.png)

Виртуальные функции определяются в базовом классе с ключевым словом virtual и они переопределяются (замещаются в производных классах). При этом прототипы функций в разных классах идентичны, но функции отличаются алгоритмами.

Три правила полиморфизма, начинают работать правильно, связывают объект и метод на этапе выполнения правильно:

- При использовании указателя на базовый класс, которому присвоен адрес объекта производного класса, вызовет метод присвоенного объекта.

- Такой же результат будет и у внешней функции, параметр которой указатель на базовый класс, а примет она в качестве параметра адрес производного класса.

- Виртуальная функция остается таковой во всех производных классах. Если она в каком-то классе не переопределена, то механизм виртуальных функций в этом классе сохраняется. Виртуальная функция может быть дружественной другому классу. При реализации виртуальной функции наследниками слово virtual не указывается.

### 16. Инкапсуляция

Инкапсуляция – объединение всех свойств объекта, определяющих его состояние и поведение в единую абстракцию и ограничение доступа к реализации. Суть инкапсуляции - доступ к данным разрешен только методам класса.

Для обеспечения скрытия данных и поддержки инкапсуляции в классах С++ используются уровни доступа к членам класса:

- `private` - список полей и методов объявленных после спецификатора private
будет доступен только методам этого класса и друзьям.
- `public` - члены класса доступные другим функциям и объектам программы
Методы этой части класса представляют интерфейс класса.
- `protected` – члены класса доступные в классе, наследникам, друзьям.

### 17. Имеются два способа сделать функцию встраиваемой. Что это за способы?

В базовом языке С директива препроцессора `#define` позволяет использовать макроопределения для записи вызова небольших часто используемых конструкций. Некорректная запись макроопределения может приводить к ошибкам, которые очень трудно найти. Макроопределения не позволяют определять локальные переменные и не выполняют проверки и преобразования аргументов.

Если вместо макроопределения использовать функцию, то это удлиняет объектный код и увеличивает время выполнения программы.
Кроме того, при работе с макроопределениями необходимо тщательно проверять раскрытия макросов, например:

```cpp
#define SUMMA(a, b) a + b
rez = SUMMA(x, y)*10;
```

После работы препроцессора получим:

```cpp
rez = x + y*10;
```

В С++ для определения функции, которая должна встраиваться как макроопределение используется ключевое слово `inline`. Вызов такой функции приводит к встраиванию кода inline-функции в вызывающую программу. Определение такой функции может выглядеть следующим образом:

```cpp
inline double SUMMA(double a, double b)
{
  return(a + b);
}
```

При вызове этой функции:

```cpp
rez = SUMMA(x,y)*10;
```

будет получен следующий результат:

```cpp
rez=(x+y)*10;
```

При определении и использовании встраиваемых функций необходимо придерживаться следующих правил:

- Определение и объявление функций должны быть совмещены и располагаться перед первым вызовом встраиваемой функции.
- Имеет смысл определять `inline` только очень небольшие функции, поскольку любая inline-функция увеличивает программный код.
- Различные компиляторы накладывают ограничения на сложность встраиваемых функций. Компилятор сам решает, может ли функция быть встраиваемой. Если функция не может быть встраиваемой, компилятор рассматривает ее как обычную функцию.

Таким образом, использование ключевого слова `inline` для встраиваемых функций и ключевого слова const для определения констант позволяют практически исключить директиву препроцессора `#define` из употребления.

### 18. Исключительные ситуации

Исключение — это событие при выполнении программы, которое приводит к её ненормальному или неправильному поведению. 

Существует два вида исключений:

- **Аппаратные** (структурные, SE-Structured Exception), которые генерируются процессором. К ним относятся, например,
  - деление на 0;
  - выход за границы массива;
обращение к невыделенной памяти
  - переполнение разрядной сетки.
- **Программные**, генерируемые операционной системой и прикладными программами – возникают тогда, когда программа их явно инициирует. Когда встречается аномальная ситуация, та часть программы, которая ее обнаружила, может сгенерировать, или **возбудить**, исключение.

Оператор `throw` позволяет сгенерировать исключительную ситуацию.

```cpp
struct MyException
{
    MyException(const char* message): _message(message) {}
    const char* what() const
    {
        return _message;
    }
private:
    const char* _message;
};

int main()
{
    try {
        throw MyException("foobar");
    } catch (const MyException& e)
    {
       std::cout << "Caught custom exception!" << std::endl
        << e.what() << std::endl; 
    }
    return 0;
}
```

Если в программе предусмотрен ее перехват, оператор `throw` должен выполняться либо внутри блока `try` , либо внутри функции, явно или неявно вызываемой внутри блока `try`.

Синтаксис `try`/`catch`

```cpp
try {
    // ...
}
catch (const typeone& arg) {
    // ...
}
catch (const typetwo& arg) {
    // ...
}
// ...
catch (const typeN& arg) {
    // ...
}
```

**блок обрабатывает все ошибки** (можно добавлять после блоков `catch`, обрабатывающих какие-либо типы аргументов:

```cpp
try {
    // ...
}
catch (...) {
    // ... handles any errors or unhandled errors
}
```

> Оператор `catch`, соответствующий базовому классу, одновременно соответствует и всем производным классам.
> 

---

**Ограничение исключительных ситуаций**

Можно ограничить типы исключительных ситуаций, которые может генерировать функция:

```cpp
template <typename T>
class MyArray
{
    T* arr;
    size_t capacity = 5;
    size_t cur_size = 2;
public:
    T& operator[](size_t pos) const throw(IndexOutOfRangeException);
};

template <typename T>
T& MyArray<T>::operator[](size_t pos) const throw(IndexOutOfRangeException) {
    if (pos >= cur_size)
        throw IndexOutOfRangeException("");
    throw "";
    return arr[pos];
}
```

Если запросить элемент, находящийся по индексу, не существующему в массиве, возникнет ошибка, перехватив которую продолжится выполнение программы.

Если же этой ошибки не возникнет, перегруженный оператор `[]` сгенерирует *неожиданное* исключение типа `const char*`, из-за которого, вне зависимости от обработки исключений, программа аварийно завершится ( на самом деле попытка сгенерировать исключительную ситуацию, не поддерживаемую функ­цией, сопровождается вызовом стандартной функции `unexpected()`. Затем по умолчанию вызывается функция `abort()`, и программа завершается аварийно.).

Если необходимо запретить функции вообще генерировать *любые* исключительные си­туации, список типов следует оставить пустым:

```cpp
template<typename T>
void MyArray<T>::print_array() const throw() {
    for (size_t i = 0; size_t < capacity; i++)
    {
        if (i)
            std::cout << " ";
        std::cout << arr[i];
    }
    std::cout << std::endl;
}
```

### 19. Класс. Назначение и синтаксис описания

**Класс** – множество объектов, имеющих общую структуру и поведение. Объекты, не связанные общностью структуры и поведения, нельзя объединять в класс. «Класс – это контракт между клиентами и абстракцией». Любой объект называют так же экземпляром класса.

Структура класса включает две части:

- **интерфейс** – внешнее устройство класса - операции доступные всем объектам системы – обязательства класса перед своими клиентами. Главное в интерфейсе – объявление операций, поддерживаемых всеми экземплярами класса.
- **реализация** – внутреннее устройство класса – реализация операций объявленных в интерфейсной части.


- Описание заголовочной части класса
  
```cpp
class MyClass {
private:
//список скрытых элементов класса
public:
MyСlass(); // конструктор
//список доступных элементов класса
~MyClass(); //деструктор
protected:
//список защищенных элементов класса
}; 
```

- Описание части реализации класса

```cpp
void MyClass::foo() {
    // тело метода (код алгоритма метода) 
}
```

### 20. Класс vector

![untitled](/assets/screenshot_12.png)
![untitled](/assets/screenshot_13.png)

`std::vector<T>` — динамический массив.

- `begin`, `end`, `rbegin`, `rend
cbegin`, `cend`, `crbegin`, `crend`
- `push_back`, `pop_back`
- `at(size_t i)` — возвращает ссылку на i-ый элемент
- `back` — возвращает ссылку на последний элемент
- `size_t capacity() const` — возвращает число элементов, которое вектор может содержать без выделения дополнительного пространства.
- `size()` — Возвращает количество элементов в векторе.
- `clear()`
- `empty()`
- `erase()` — Удаляет элемент или диапазон элементов в векторе из заданных позиций.
итератор или итераторы  begin-end `[it_beg; it_end)`
- `insert()` — вставляет элемент или несколько элементов или диапазон элементов в указанную позиции в вектор.

### 21. Класс string

В `С` для представления строк используется строка, завершающаяся
нулем. Эта строка используется и в `С++`. В `С++` применяется еще и класс
`String`.

Этот тип строк - это объект шаблонного класса `basic_string`.

Строка `string` из `<string>` это производный тип от `basic_string`, а `wstring` – широкая строка (Unicode). Инкапсулирует последовательность символов.

Строка является динамической, растет по мере добавления символов.

Количество символов, которые будет содержать строка, не является предопределенным. Объект класса `string` будет расти по мере необходимости, чтобы вместить строку, которую эта переменная должна хранить. При создании строковой переменной ей выделяется первоначальный объем памяти, чтобы сохранить значение строки. Используя метод `capacity()` можно определить размер необходимо памяти. При выполнении операций добавления, если в переменной недостаточно места, размер автоматически увеличивается на 16 байт при каждом расширении.

```cpp
std::cin >> s1; //до разделителя и \n и \n не читает
getline(cin, s1); //читает всю строку
```

- `size()`/`length()`
- `c_str()` — возвращает строку, преобразованную в C-строку
- `starts_with()`/`ends_with()`
- `std::string substr(size_t offset = 0, size_t count = npos)` — Копирует из указанного положения в строке подстроку, содержащую по крайней мере несколько символов

```cpp
std::string s = "Hello, World!123 12 3123 123 123 3 123123 123";
    std::cout << s.substr(0, 13) << std::endl; // Hello, World!
```

- `find`/`rfind`

```cpp
std::string s = "Hello, World!123 12 3123 123 123 3 123123 123";

size_t pos = s.find("World");
size_t pos_end = s.find_last_of("World");

std::cout << pos << " "  << pos_end << std::endl; // 7 11
```

- `copy(char* c, size_t n, size_t offset = 0) const` — копирует часть строки в `c`
- `replace()` — заменяет элементы в строке в указанной позиции заданными символами или символами, скопированными из других диапазонов, строк или C-строк.
- `append()` - добавляет символы в конец строки
- `erase()` - удаляет элемент или диапазон элементов с указанного положения в строке

```cpp
iterator erase(
    iterator first,
    iterator last);

iterator erase(
    iterator iter);

basic_string<CharType, Traits, Allocator>& erase(
    size_type offset = 0,
    size_type count = npos);
```

- `find_last_of` — Выполняет в строке поиск последнего символа, совпадающего с любым элементом заданной строки.
- `capacity()`
- `static const size_type npos = -1` — целочисленное значение без знака, инициализированное значением -1, которое указывает на отсутствие найденных или всех оставшихся символов при сбое функции поиска.

1.  Какая инструкция catch перехватывает все типы исключительных
ситуаций?

23. Какова основная форма конструктора копий?
24. Конструктор копии.
25. Контейнеры и итераторы.
26. Контейнер – динамический массив.
27. Какое условие является обязательным для присвоения одного объекта
другому?
28. Контейнер – ассоциативный список.
29. Какой тип операций ведет к вызову конструктора копий?
30. Конструктор и деструктор объекта.
31. Класс map и multimap.
32. Можно ли адрес объекта передать функции в качестве аргумента?
33. Множественное наследование.
34. Можно ли использовать инструкцию throw, если ход выполнения
программы не затрагивает инструкции, расположенные в блоке try?
35. Может ли быть инициализирован массив, память для которого
выделяется динамически?
36. Наследование. Реализация наследования на языке С++.
37. Объявление элементов класса спецификацией static.
38. Объявление элементов класса спецификацией const.
39. Объявление объекта и доступ к его элементам.
40. Объединение. Назначение и синтаксис описания.
41. Объекты в качестве возвращаемого значения функции.
42. Определение адреса перегруженной функции.
43. Определение системы и три примера систем.
44. Перегрузка бинарных операторов.
45. При наследовании одного класса другим, когда вызываются
конструкторы классов? Когда вызываются их деструкторы?
46. Полиморфизм.
47. Параметризированные конструкторы.
48. Программа – система.
50. Перегрузка оператора индексации массивов [ ]
51. Присвоение объектов.
52. Приведение типов.
53. Перегрузка функций.
54. Перегрузка унарных операторов.
55. Структура. Назначение и синтаксис описания.
56. Операторы new и delete.
57. Сигналы и обработчики.
58. Форматированный ввод-вывод данных.
59. Что такое родовой класс и какова его основная форма?
60. Что происходит, когда открытые члены базового класса наследуются как
открытые? Что происходит, когда они наследуются как закрытые?
61. Чисто виртуальные функции и абстрактные классы.
62. Что такое родовая функция и какова ее основная форма?
63. Что такое встраиваемая функция? В чем ее преимущества и недостатки?
64. Чем действие дружественной оператор-функции отличается от действия
оператор-функции — члена класса?
65. Что такое объект?
66. Что происходит с защищенным членом класса, когда класс наследуется
как открытый? Что происходит, когда он наследуется как закрытый?
67. Управление доступом к элементам класса.
68. Указатели и ссылки на объект.
69. Указатель на объект производного класса
70. Управление доступом при наследовании.
71. Указатель this.
72. Шаблон класса.
73. Шаблон функции.