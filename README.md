# OOP-exam-questions

## Вопросы к экзамену по ООП

### 1 Аргументы, передаваемые функции по умолчанию

В C++ мы можем придать параметру некоторое значение, которое будет автоматически использовано, если при вызове функции не задается аргумент, соответствующий этому параметру. Аргументы, передаваемые функции по умолчанию, можно использовать, чтобы упростить обращение к сложным функциям, а также в качестве "сокращенной формы" перегрузки функций.

 ```cpp
 void myfunc(double num = 0.0, char ch = 'Х')
{
    ///
}
```

После такого объявления функцию myfunc() можно вызвать одним из трех следующих способов.

```cpp
myFunc(198.234, 'A'); // Передаем явно заданные значения.
 ```

```cpp
myfunc(10.1); // Передаем для параметра num значение 10.1, а для параметра ch позволяем применить аргумент, задаваемый по умолчанию ('Х').
 ```

```cpp
myfunc(); // Для обоих параметров num и ch позволяем применить аргументы, задаваемые по умолчанию.
```

При первом вызове параметру num передается значение `198.234`, а параметру `ch` — символ `'А'`. Во время второго вызова параметру num передается значение `10.1`, а параметр `ch` по умолчанию устанавливается равным символу `'Х'`. Наконец, в результате третьего вызова как параметр `num`, так и параметр `ch` по умолчанию устанавливаются равными значениям, заданным в объявлении функции.

**Аргумент**, передаваемый функции **по умолчанию**, представляет собой значение, которое будет автоматически передано параметру функции в случае, если аргумент, соответствующий этому параметру, явным образом не задан.

### 2. Архитектура системы. Иерархия объектов

![untitled](/assets/screenshot_5.png)

Архитектура системы так или иначе строится путем создания иерархии объектов и взаимодействия между объектами.

Наследование поддерживает иерархические отношения между классами – is a. Основой выявления таких отношений, является исследование задачи, проведение классификации выявленных сущностей – классов, определения их общих свойств и поведения. На верхний уровень иерархии выносятся свойства и операции общие для всех сущностей, далее уровни выстраиваются по такому же принципу.

![untitled](/assets/screenshot_3.png)

### 3. Ввод-вывод в С++. Потоки

Текстовый поток — это последовательность символов, к которым можно получить доступ. Со временем поток может производить или потреблять потенциально неограниченные объемы данных.

В C++ для ввода и вывода используются потоки `cin` и `cout`.

### 4. В чем различие между ссылкой и указателем?

![untitled](/assets/screenshot_9.png)
![untitled](/assets/screenshot_10.png)

Чтобы использовать свойства и методы через указатель на объект, необходимо использовать `->` вместо `.`

```cpp
class MyClass {
public:
  void foo();
};

int main() {
  MyClass obj;
  MyClass obj_ptr = &obj;
  obj_ptr->foo();
}
```

В Visual C++ (CLR – Common Language Runtime) поддерживаются три типа указателей:

- управляемые указатели (managed pointers);
- неуправляемые указатели (unmanaged pointers);
- неуправляемые указатели на функции (unmanaged function pointers).

Отличие между управляемыми и неуправляемыми указателями состоит в следующем: в отличие от управляемого указателя неуправляемому указателю можно присвоить любой адрес памяти, даже той, которая находится за пределами исполнительной среды. В этом случае память является **нерегулируемой**.

 В случае **регулируемой** памяти управляемому указателю присвоить адрес за пределами исполнительной среды не удастся.

 **Управляемые указатели** – это указатели ссылочного типа. Эти указатели передаются для аргументов, методов, которые передаются по ссылке.

Управляемые указатели являются ссылками на объекты. Эти объекты
размещаются в общей управляемой памяти, которая выделяется для программы в момент ее выполнения.

В таких указателях вместо символа ‘*’ применяется символ ‘^’. Для
выделения.

**Неуправляемые указатели** (unmanaged pointer) – это традиционные
указатели C/C++. Они являются указателями на объекты в неуправляемом
объеме памяти, которая выделяется для выполнения программы.
Неуправляемые указатели не являются совместимыми со спецификацией CLR.

**Неуправляемые указатели на функции** – это указатели на функции,
которые можно обрабатывать таким же образом, как и неуправляемые
указатели на объекты (данные).

Чтобы использовать свойства и методы через указатель на объект, необходимо использовать -> вместо.

### 5. Виртуальные базовые классы

При множественном наследовании может возникнуть неоднозначность.

В качестве примера, рассмотрим следующую задачу. Класс ChildClass является наследником классов ParentClass1 и ParentClass2.

```cpp
class BaseClass {
public:
  int num;
};

class ParentClass1 : public BaseClass{
  
};

class ParentClass2 : public BaseClass{
  
};

class ChildClass : public ParentClass1, public  ParentClass2 {
};

int main() {
   ChildClass obj;
   obj.num = 1;
   // Ошибка! неявное имя переменной
   return 0;
}
```

Программу можно исправить двумя способами:

1. Применить оператор разрешения области видимости `::` к переменной num

```cpp
class BaseClass {
public:
  int num;
};

class ParentClass1 : public BaseClass{
  
};

class ParentClass2 : public BaseClass{
  
};

class ChildClass : public ParentClass1, public  ParentClass2 {
};

int main() {
   ChildClass obj;
   obj.ParentClass1::num = 1;
   return 0;
}
```

Оператор разрешения области видимости `::` позволяет явно выбрать вариант производного класса. Однако данный способ решения порождает проблемы: Что если на самом деле нужна лишь одна копия объекта, можно ли предот­вратить дублирование объектов?

1. Использование виртуальных базовых классов

```cpp
class BaseClass {
public:
  int num;
};

class ParentClass1 : virtual public BaseClass {
  
};

class ParentClass2 : virtual public BaseClass {
  
};

class ChildClass : public ParentClass1, public  ParentClass2 {
};

int main() {
   ChildClass obj;
   obj.num = 1;
   return 0;
}
```

Как видим, перед именем базового класса в спецификации производного класса стоит ключевое слово `virtual`.

Теперь оба класса являются наследниками виртуального базового класса `BaseClass`, и любые их наследники будут со­ держать лишь одну его копию. Следовательно, выражение `obj.num = 1` становится однозначным

### 6. Взаимодействие объектов. Три примера взаимодействия объектов

При использовании технологи ООП решение задачи представляется в виде результата **взаимодействия** отдельных функциональных элементов (объектов/экземпляров) некоторой системы, происходящие в предметной области поставленной задачи.

В такой системе, каждый входящий функциональный элемент, получив некоторое входное воздействие (сообщение), выполняет заранее определенное действие.

Например, он может:

- опустить монету в автомат по продаже газет;
- нарисовать круг или квадрат;
- вычислить их площадь или периметр;
  
т.е. он воздействует на себя или на другой объект, изменяя состояние себя или другого элемента. Передавая сообщения, от элемента к элементу, система выполняет определенные действия.

![untitled](/assets/screenshot_2.png)

### 7. Виртуальные методы. Наследование виртуальных методов

Виртуальная функция — функция-член, объявленная в базовом классе и переопределенная в производном.

Чтобы создать виртуальную функ­цию, следует указать ключевое слово `virtual` перед ее объявлением в базовом классе.

По существу, виртуальная функция реализует принцип “один интер­фейс, несколько методов”, лежащий в основе полиморфизма.

При наследовании виртуальной функции ее виртуальная природа также наследует­ся.

Виртуальные функции являются иерархическими.

Виртуальную функцию не обязательно определять в классе наследнике. В этом случае вызывается функция, определенная в базовом классе.

### 8. В чем отличие между классом и структурой?

В `С++` основная разница между структурой и классом - это модификатор доступа, который используется по умолчанию для их членов. Для классов, по умолчанию используется модификатор `private`, а для структур - `public`.

### 9. Встраиваемая функция

В ООП при разработке классов создается много маленьких функций, это порождает много вызовов, что затратно по времени. В С++ преодолеть эту трудность помогают функции - подстановки (inline).

Такие функции можно определить в классе, а можно объявить в классе как обычную функцию – член, а реализовать вне класса как функцию inline.

Тела функций встраиваются в код на месте вызова этой функции при выполнении препроцессорной обработки

```cpp
inline void foo() {
  // тело функции
}
```

### 10.  Для чего используется ключевое слово protected?

Модификатор доступа `protected` (защищённый) разрешает доступ самому классу, наследующим его классам и родительским классам.

### 11.  Дружественная функция

**Дружественная функция** не является членом класса, но получает доступ к закрытым элементам объекта класса.

Методы класса используются для реализации свойств объекта. В виде
дружественных функции оформляются действия, не представляющие свойства класса, но концептуально входящие в состав класса и нуждающиеся в доступе к его скрытым полям, например, переопределение операции вывода объекта в поток вывода.

Правила использования:

- Объявляется внутри функции при помощи ключевого слова `friend`.
- В качестве параметра ей должен передаваться объект, ссылка или
указатель на объект, так как указатель `this` ей не доступен.
- Дружественная функция может быть внешней функцией или методом
другого класса.
- Определение дружественной функции осуществляется вне класса,
действие спецификатора доступа на нее не распространяется.

Обычно дружественные функции используются для перегрузки операторов или имеют вспомогательное назначение — например, вывод.

```cpp
friend void foo();
```

### 12.  Дружественный класс

Класс можно объявить дружественным по отношению к другому классу при ключевого слова `friend`. В таком случае в классе можно будет получить доступ к приватным и защищённым свойствам и методам другого класса.

```cpp
class MyClass1 {
friend class MyClass2;
}
```

### 12.  Защищенные члены класса

Если необходимо защитить член класса от доступа извне, но позволить использовать его производным классам, используется другое ключевое слово — protected (защищенный). Если продолжить аналогию, это напоминает семейную ценность, передаваемую по наследству.

Защищен­ный член подобен частному, за исключением механизма наследования. При наследовании защищенного члена производный класс также имеет к нему доступ. Таким образом, указав специфи­катор доступа protected, можно позволить использовать атрибуты и методы внутри иерархии и запретить доступ к нему извне этой иерархии.

```cpp
class MyClass {
protected:
  //защищенные члены класса
};
```

### 14. Жизненный цикл объекта

![untitled](/assets/screenshot_1.png)

### 15. Жизненный цикл виртуального объекта и его реализация на языке С++

![untitled](/assets/screenshot_11.png)

Виртуальные функции определяются в базовом классе с ключевым словом virtual и они переопределяются (замещаются в производных классах). При этом прототипы функций в разных классах идентичны, но функции отличаются алгоритмами.

Три правила полиморфизма, начинают работать правильно, связывают объект и метод на этапе выполнения правильно:

- При использовании указателя на базовый класс, которому присвоен адрес объекта производного класса, вызовет метод присвоенного объекта.

- Такой же результат будет и у внешней функции, параметр которой указатель на базовый класс, а примет она в качестве параметра адрес производного класса.

- Виртуальная функция остается таковой во всех производных классах. Если она в каком-то классе не переопределена, то механизм виртуальных функций в этом классе сохраняется. Виртуальная функция может быть дружественной другому классу. При реализации виртуальной функции наследниками слово virtual не указывается.

### 16. Инкапсуляция

Инкапсуляция – объединение всех свойств объекта, определяющих его состояние и поведение в единую абстракцию и ограничение доступа к реализации. Суть инкапсуляции - доступ к данным разрешен только методам класса.

Для обеспечения скрытия данных и поддержки инкапсуляции в классах С++ используются уровни доступа к членам класса:

- `private` - список полей и методов объявленных после спецификатора private
будет доступен только методам этого класса и друзьям.
- `public` - члены класса доступные другим функциям и объектам программы
Методы этой части класса представляют интерфейс класса.
- `protected` – члены класса доступные в классе, наследникам, друзьям.

### 17. Имеются два способа сделать функцию встраиваемой. Что это за способы?

В базовом языке С директива препроцессора `#define` позволяет использовать макроопределения для записи вызова небольших часто используемых конструкций. Некорректная запись макроопределения может приводить к ошибкам, которые очень трудно найти. Макроопределения не позволяют определять локальные переменные и не выполняют проверки и преобразования аргументов.

Если вместо макроопределения использовать функцию, то это удлиняет объектный код и увеличивает время выполнения программы.
Кроме того, при работе с макроопределениями необходимо тщательно проверять раскрытия макросов, например:

```cpp
#define SUMMA(a, b) a + b
rez = SUMMA(x, y)*10;
```

После работы препроцессора получим:

```cpp
rez = x + y*10;
```

В С++ для определения функции, которая должна встраиваться как макроопределение используется ключевое слово `inline`. Вызов такой функции приводит к встраиванию кода inline-функции в вызывающую программу. Определение такой функции может выглядеть следующим образом:

```cpp
inline double SUMMA(double a, double b)
{
  return(a + b);
}
```

При вызове этой функции:

```cpp
rez = SUMMA(x,y)*10;
```

будет получен следующий результат:

```cpp
rez=(x+y)*10;
```

При определении и использовании встраиваемых функций необходимо придерживаться следующих правил:

- Определение и объявление функций должны быть совмещены и располагаться перед первым вызовом встраиваемой функции.
- Имеет смысл определять `inline` только очень небольшие функции, поскольку любая inline-функция увеличивает программный код.
- Различные компиляторы накладывают ограничения на сложность встраиваемых функций. Компилятор сам решает, может ли функция быть встраиваемой. Если функция не может быть встраиваемой, компилятор рассматривает ее как обычную функцию.

Таким образом, использование ключевого слова `inline` для встраиваемых функций и ключевого слова const для определения констант позволяют практически исключить директиву препроцессора `#define` из употребления.

### 18. Исключительные ситуации

Исключение — это событие при выполнении программы, которое приводит к её ненормальному или неправильному поведению.

Существует два вида исключений:

- **Аппаратные** (структурные, SE-Structured Exception), которые генерируются процессором. К ним относятся, например,
  - деление на 0;
  - выход за границы массива;
обращение к невыделенной памяти
  - переполнение разрядной сетки.
- **Программные**, генерируемые операционной системой и прикладными программами – возникают тогда, когда программа их явно инициирует. Когда встречается аномальная ситуация, та часть программы, которая ее обнаружила, может сгенерировать, или **возбудить**, исключение.

Оператор `throw` позволяет сгенерировать исключительную ситуацию.

```cpp
struct MyException
{
    MyException(const char* message): _message(message) {}
    const char* what() const
    {
        return _message;
    }
private:
    const char* _message;
};

int main()
{
    try {
        throw MyException("foobar");
    } catch (const MyException& e)
    {
       std::cout << "Caught custom exception!" << std::endl
        << e.what() << std::endl; 
    }
    return 0;
}
```

Если в программе предусмотрен ее перехват, оператор `throw` должен выполняться либо внутри блока `try` , либо внутри функции, явно или неявно вызываемой внутри блока `try`.

Синтаксис `try`/`catch`

```cpp
try {
    // ...
}
catch (const typeone& arg) {
    // ...
}
catch (const typetwo& arg) {
    // ...
}
// ...
catch (const typeN& arg) {
    // ...
}
```

**блок обрабатывает все ошибки** (можно добавлять после блоков `catch`, обрабатывающих какие-либо типы аргументов:

```cpp
try {
    // ...
}
catch (...) {
    // ... handles any errors or unhandled errors
}
```

> Оператор `catch`, соответствующий базовому классу, одновременно соответствует и всем производным классам.
>

---

#### Ограничение исключительных ситуаций

Можно ограничить типы исключительных ситуаций, которые может генерировать функция:

```cpp
template <typename T>
class MyArray
{
    T* arr;
    size_t capacity = 5;
    size_t cur_size = 2;
public:
    T& operator[](size_t pos) const throw(IndexOutOfRangeException);
};

template <typename T>
T& MyArray<T>::operator[](size_t pos) const throw(IndexOutOfRangeException) {
    if (pos >= cur_size)
        throw IndexOutOfRangeException("");
    throw "";
    return arr[pos];
}
```

Если запросить элемент, находящийся по индексу, не существующему в массиве, возникнет ошибка, перехватив которую продолжится выполнение программы.

Если же этой ошибки не возникнет, перегруженный оператор `[]` сгенерирует *неожиданное* исключение типа `const char*`, из-за которого, вне зависимости от обработки исключений, программа аварийно завершится ( на самом деле попытка сгенерировать исключительную ситуацию, не поддерживаемую функ­цией, сопровождается вызовом стандартной функции `unexpected()`. Затем по умолчанию вызывается функция `abort()`, и программа завершается аварийно.).

Если необходимо запретить функции вообще генерировать *любые* исключительные си­туации, список типов следует оставить пустым:

```cpp
template<typename T>
void MyArray<T>::print_array() const throw() {
    for (size_t i = 0; size_t < capacity; i++)
    {
        if (i)
            std::cout << " ";
        std::cout << arr[i];
    }
    std::cout << std::endl;
}
```

### 19. Класс. Назначение и синтаксис описания

**Класс** – множество объектов, имеющих общую структуру и поведение. Объекты, не связанные общностью структуры и поведения, нельзя объединять в класс. «Класс – это контракт между клиентами и абстракцией». Любой объект называют так же экземпляром класса.

Структура класса включает две части:

- **интерфейс** – внешнее устройство класса - операции доступные всем объектам системы – обязательства класса перед своими клиентами. Главное в интерфейсе – объявление операций, поддерживаемых всеми экземплярами класса.
- **реализация** – внутреннее устройство класса – реализация операций объявленных в интерфейсной части.

- Описание заголовочной части класса
  
```cpp
class MyClass {
private:
//список скрытых элементов класса
public:
MyСlass(); // конструктор
//список доступных элементов класса
~MyClass(); //деструктор
protected:
//список защищенных элементов класса
}; 
```

- Описание части реализации класса

```cpp
void MyClass::foo() {
    // тело метода (код алгоритма метода) 
}
```

### 20. Класс vector

![untitled](/assets/screenshot_12.png)
![untitled](/assets/screenshot_13.png)

`std::vector<T>` — динамический массив.

- `begin`, `end`, `rbegin`, `rend
cbegin`, `cend`, `crbegin`, `crend`
- `push_back`, `pop_back`
- `at(size_t i)` — возвращает ссылку на i-ый элемент
- `back` — возвращает ссылку на последний элемент
- `size_t capacity() const` — возвращает число элементов, которое вектор может содержать без выделения дополнительного пространства.
- `size()` — Возвращает количество элементов в векторе.
- `clear()`
- `empty()`
- `erase()` — Удаляет элемент или диапазон элементов в векторе из заданных позиций.
итератор или итераторы  begin-end `[it_beg; it_end)`
- `insert()` — вставляет элемент или несколько элементов или диапазон элементов в указанную позиции в вектор.

### 21. Класс string

В `С` для представления строк используется строка, завершающаяся
нулем. Эта строка используется и в `С++`. В `С++` применяется еще и класс
`String`.

Этот тип строк - это объект шаблонного класса `basic_string`.

Строка `string` из `<string>` это производный тип от `basic_string`, а `wstring` – широкая строка (Unicode). Инкапсулирует последовательность символов.

Строка является динамической, растет по мере добавления символов.

Количество символов, которые будет содержать строка, не является предопределенным. Объект класса `string` будет расти по мере необходимости, чтобы вместить строку, которую эта переменная должна хранить. При создании строковой переменной ей выделяется первоначальный объем памяти, чтобы сохранить значение строки. Используя метод `capacity()` можно определить размер необходимо памяти. При выполнении операций добавления, если в переменной недостаточно места, размер автоматически увеличивается на 16 байт при каждом расширении.

```cpp
std::cin >> s1; //до разделителя и \n и \n не читает
getline(cin, s1); //читает всю строку
```

- `size()`/`length()`
- `c_str()` — возвращает строку, преобразованную в C-строку
- `starts_with()`/`ends_with()`
- `std::string substr(size_t offset = 0, size_t count = npos)` — Копирует из указанного положения в строке подстроку, содержащую по крайней мере несколько символов

```cpp
std::string s = "Hello, World!123 12 3123 123 123 3 123123 123";
    std::cout << s.substr(0, 13) << std::endl; // Hello, World!
```

- `find`/`rfind`

```cpp
std::string s = "Hello, World!123 12 3123 123 123 3 123123 123";

size_t pos = s.find("World");
size_t pos_end = s.find_last_of("World");

std::cout << pos << " "  << pos_end << std::endl; // 7 11
```

- `copy(char* c, size_t n, size_t offset = 0) const` — копирует часть строки в `c`
- `replace()` — заменяет элементы в строке в указанной позиции заданными символами или символами, скопированными из других диапазонов, строк или C-строк.
- `append()` - добавляет символы в конец строки
- `erase()` - удаляет элемент или диапазон элементов с указанного положения в строке

```cpp
iterator erase(
    iterator first,
    iterator last);

iterator erase(
    iterator iter);

basic_string<CharType, Traits, Allocator>& erase(
    size_type offset = 0,
    size_type count = npos);
```

- `find_last_of` — Выполняет в строке поиск последнего символа, совпадающего с любым элементом заданной строки.
- `capacity()`
- `static const size_type npos = -1` — целочисленное значение без знака, инициализированное значением -1, которое указывает на отсутствие найденных или всех оставшихся символов при сбое функции поиска.

### 22. Какая инструкция catch перехватывает все типы исключительных ситуаций?

Бывают случаи, когда нужно перехватить все исключительные ситуации подряд. Для этого, в C++ используется блок catch(…), который имеет следующую общую форму

```cpp
catch(...)
{
  // Обработка всех исключительных ситуаций
  // ...
}
```

### 23. Какова основная форма конструктора копий?

```cpp
MyClass(int a); // конструктор копирования
```

### 24. Конструктор копии

Стандартный конструктор копирования, который осуществляет поэлементное копирование однотипных объектов. Вызывается при присваивании объектов одного типа.

Не стандартный конструктор копирования (создается программистом) включается в класс, в котором есть динамически создаваемые члены данных.

Такой конструктор имеет один параметр – ссылку на объект своего класса.

```cpp
class MyClass {
  int a;
public:
  MyClass(int a); // конструктор копирования
};

MyClass::MyClass(int a) {
  this->a = a;
}
```

### 25. Контейнеры и итераторы

![untitled](/assets/screenshot_14.png)
![untitled](/assets/screenshot_15.png)

Основные контейнеры:

- `std::vector`
- `std::list`
- `std::set`
- `std::map`
- `std::queue`

Итераторы STL-контейнеров:

- `begin`, `end`, `rbegin`, `rend`
- `cbegin`, `cend`, `crbegin`, `crend`

### 26. Контейнер – динамический массив

Это есть `std::vector`

### 27. Какое условие является обязательным для присвоения одного объекта другому?

Если тип двух объектов одинаков, то один объект можно присвоить другому. По умолчанию, когда один объект присваивается другому, делается побитовая копия всех атрибутов копируемого объекта.

Стандартное присваивание можно переопределить, перегрузив оператор присваивания для конкретного класса.

### 28. Контейнер – ассоциативный список

Есть `std::map`

### 29. Какой тип операций ведет к вызову конструктора копий?

Конструктор копирования, в отличии от других, в качестве параметра принимает константную ссылку на объект класса.

```cpp
//Прототип конструктора копирования
Class(const Class &);
```

### 30. Конструктор и деструктор объекта

**Конструктор** класса - это метод, обеспечивающие создание(инициализацию полей) экземпляров класса (объектов). Объект это переменная класса.

В классе С++ может быть несколько конструкторов, т.к. для них допускается перегрузка.

Виды конструкторов:

Виды конструкторов:

- **Конструктор по умолчанию**.
 Если программист не включил в класс ни одного конструктора, то компилятор создаст его автоматически, и он будет вызывается автоматически при определении объекта.
- **Явно определенный конструктор**.
 Такой конструктор реализуется по формату функции, его имя – это имя класса, эта функция не имеет типа.
  - *Без параметров* – его называют конструктором по умолчанию.
  - *С параметрами* – создает объект и инициализирует члены данных значениями параметров. В классе может быть несколько перегруженных конструкторов с различным количеством параметров. Параметры могут быть любого типа, кроме типа этого класса.
- **Конструктор копирования**.
 Такой конструктор реализуется по формату функции, его имя – это имя класса, эта функция не имеет типа, даже void.
  - *Стандартный конструктор копирования* – осуществляет поэлементное копирование однотипных объектов. Вызывается при присваивании объектов одного типа.
  - *Не стандартный конструктор копирования* – (создается программистом) включается в класс, в котором есть динамически создаваемые члены данных. Такой конструктор имеет один параметр – ссылку на объект своего класса.

```cpp
class MyClass {
public:
  MyClass(); // конструктор
};
```

**Деструктор** - метод, обеспечивающий правильное удаление объектов.

Виды деструкторов:

- **Деструктор по умолчанию**. Вызывается автоматически, когда объект выходит из области видимости. Видимость объектов определяется по правилам видимости локальных, глобальных, статических переменных.
- **Явно определенный деструктор**. Требуется, если среди членов данных имеются динамические переменные, которые удаляются другими средствами.

```cpp
class MyClass {
public:
  ~MyClass(); // деструктор
};
```

### 31. Класс map и multimap

![untitled](/assets/screenshot_16.png)
![untitled](/assets/screenshot_17.png)
![untitled](/assets/screenshot_18.png)
![untitled](/assets/screenshot_19.png)

`std::map<K, V>` — ассоциативный массив, хранящий значения типа `V` по ключам типа `K`.

- те же методы, что и у `multimap`

`std::multimap<K, V>` — *мультиотображение* — множество, в которое каждый элемент может входить несколько раз

```cpp
#include <map>
#define int_pair std::pair<int, int>

template <typename K, typename V>
void show(const std::multimap<K, V>& mm)
{
    for (typename std::multimap<K, V>::const_iterator it = mm.begin(); it != mm.end(); it++)
        std::cout << it->first << " " << it->second << std::endl;
}
```

- `multimap::begin()`, `multimap::end()` — возвращает итератор, адресующий первый элемент в мультиотображении.
- `rbegin`, `rend`
- `multimap::cbegin()`, `multimap::cend()` — возвращает константный итератор, адресующий первый элемент в мультиотображении.
- `crbegin`, `crend`
- `multimap::insert(std::pair)` — вставляет в мультиотображение пару ключ-значение, представляемую парой `std::pair<K, V>`.
- `multimap::count(const K&)` — возвращает число элементов в мультиотображении, ключи которых совпадают с ключом, заданным параметром.
- `bool multimap::contains(const &K)` — проверяет, существует ли элемент с указанным ключом в `multimap`
- `multimap::empty()` — проверяет, что мультиотображение пусто — возвращает **`true`**, если `multimap` пусто; **`false` е**сли `multimap` не является пустым.
- `multimap::clear()` — удаляет все элементы мультиотображения
- `multimap::size()` — возвращает размер мультиотображения
- `multimap::find(const K&)` — возвращает итератор, ссылающийся на элемент в мультикарте, ключ которого эквивалентен заданному ключу.
- `multimap::erase(const_iterator Where)`/`multimap::erase(const_iterator First, const_iterator Second)`/`multimap::erase(const K&)`
- `multimap::equal_range` — Находит диапазон элементов, где ключ элемента соответствует заданному значению.

```cpp
pair<const_iterator, const_iterator> equal_range (const Key& key) const;

pair<iterator, iterator> equal_range (const Key& key);
```

### 32. Можно ли адрес объекта передать функции в качестве аргумента?

Передача аргумента по адресу включает в себя передачу не самой переменной аргумента, а ее адреса.

Поскольку аргумент является адресом, параметр функции должен быть указателем. Затем, чтобы получить доступ или изменить значение, на которое указывает указатель, функция может разыменовать его.

### 33. Множественное наследование

Множественное наследование - это создание нового класса на основе нескольких существующих классов.

```cpp
class ParentClass1 {
  // тело класса
};

class ParentClass2 {
  // тело класса
};

class ChildClass: public /* protected | private*/ ParentClass1, public /* protected | private*/  ParentClass2 {
  // тело класса
};
```

### 34. Можно ли использовать инструкцию throw, если ход выполнения программы не затрагивает инструкции, расположенные в блоке try?

Фактически обработка исключений – это работа блока (ов) `catch`. Ключевое слово `catch` используется для определения блока кода (называемого блоком `catch`), который обрабатывает исключения для одного типа данных.

Вот пример блока `catch`, который перехватывает исключения со значениями int:

```cpp
catch (int x)
{
    // Здесь обрабатываем исключение типа int
    std::cerr << "We caught an int exception with value" << x << '\n';
}
```

Блоки `try` и блоки `catch` работают вместе – блок `try` обнаруживает любые исключения, которые вызываются инструкциями в блоке `try`, и направляет их для обработки в соответствующий блок `catch`. Блок `try` должен иметь сразу после себя, по крайней мере, один блок `catch`, но он также может иметь несколько блоков `catch`, идущих последовательно.

Как только исключение было перехвачено блоком `try` и направлено в блок `catch` для обработки, исключение считается обработанным, и выполнение возобновится в обычном режиме после блока `catch`.

### 35. Может ли быть инициализирован массив, память для которого выделяется динамически?

Для использования функций динамического выделения памяти необходимо описать указатель, представляющий собой начальный адрес хранения элементов массива.

```cpp
int *p; // указатель на тип int
```

Начальный адрес статического массива определяется компилятором в момент его объявления и не может быть изменен.

Для динамического массива начальный адрес присваивается объявленному указателю на массив в процессе выполнения программы.

Функции динамического выделения памяти находят в оперативной памяти непрерывный участок требуемой длины и возвращают начальный адрес этого участка.

### 36.  Наследование. Реализация наследования на языке С++

**Наследование** – механизм создания нового класса на основе уже существующего.

**Наследование** - возможность создания производных классов (классов наследников), взяв за основу методы и элементы базового класса (класса родителя).

Язык С++ поддерживает реализацию двух видов наследования:

- Простое, новый класс формируется на основе одного существующего класса
- Множественное, создание нового класса на основе нескольких существующих классов

```cpp
class ChildClass : public /* private | protected */  ParentClass {
    // тело класса
};
```

### 37.  Объявление элементов класса спецификацией static

Члены класса могут быть статическими.
Независимо от количества объектов класса, статическая переменная всегда существует в одном экземпляре.

Объявление статической переменной-члена в классе не означает ее определения (иначе говоря, память для нее не выделяется). Чтобы разместить статическую переменную в памяти, следует определить ее вне класса, т.е. глобально.

```cpp
class Shared
{
    static int n;
    int b;
public:
    void increment() const;
    static void show();
};

int Shared::n; // int Shared::n = 0;
void Shared::increment() const
{
    Shared::n++;
}
void Shared::show()
{
    std::cout << Shared::n << std::endl;
}

int main()
{
    Shared o;
    Shared::show();
    o.increment();
    Shared::show();

    return 0;
}
class Counter
{
public:
    static int count;
    Counter() { count++; }
    ~Counter() { count--; }
};

int Counter::count = 0;
```

### 38.  Объявление элементов класса спецификацией const

Если объявить поле класса со спецификацией `const`, при создании каждого нового объекта будет выделяться память для хранения значения переменной, которая представляет это поле класса.

Если объявить статическое поле класса со спецификацией `const`, при определении (определять нужно явно) поля память для хранения значения выделится единожды, далее значение нельзя будет изменить.

```cpp
class Counter
{
public:
    static const int count;
};

const int Counter::count = 15;
```

Если объявить метод-член класса со спецификацией `const`, в методе нельзя будет изменить значения полей класса или вызвать методы, делающие это:

```cpp
class Counter
{
    int count;
public:
    Counter(int n = 0): count(n) {}
    int increment() { return ++count; }
    void show() const { std::cout << count << std::endl; }
    ~Counter() {}
};
```

### 39.  Объявление объекта и доступ к его элементам

Чтобы объявить объект, необходимо указать класс/тип объекта, а затем имя объекта.

Чтобы использовать свойства и методы объекта, необходимо использовать `.` после его имени.

```cpp
class MyClass {
public:
  void foo();
};

int main() {
  MyClass obj; // объявление объекта
  obj.foo(); // вызов метода объекта
}
```

### 40. Объединение. Назначение и синтаксис описания

На структуры во многом похожи объединения. Объединения также хранят набор элементов, но в отличие от структуры все элементы объединения имеют нулевое смещение. А это значит, что разные элементы занимают в памяти один и тот же участок.

Для определения объединений применяется ключевое слово union и следующий формальный синтаксис:

```cpp
union _name //имя_объединения
{
    //определения_элементов
};
```

Фактически объединение определяется точно также, как и структура, только вместо слова struct используется ключевое слово `union`.

Так, создадим простейшее объединение:

```cpp
union code
{
    int digit;
    char letter;
};
```

Объединение code хранит в одном и том же участки памяти объект int и объект char.
Объединение сode на большинстве платформ будет занимать 4 байта. Длина элементов, как здесь, может быть разной, и в этом случае размер объединения вычисляется по наибольшему элементу.

### 41.  Объекты в качестве возвращаемого значения функции

Когда функция возвращает объект, автоматически создается временный объект, содержащий возвращаемое значение. Именно этот объект фактически возвращается функцией. После того, как значение возвращено, этот объект уничтожается.

Уничтожение временного объекта может вызывать неожиданные побочные эффекты в некоторых ситуациях. Например, если возвращае­мый функцией объект имеет деструктор, освобождающий динамически зарезервированную па­мять. Для решения этой проблемы используется перегрузка оператора присваивания и определение конструктора копирования.

### 42. Определение адреса перегруженной функции

Функция имеет адрес. Этот адрес можно присвоить указателю, а затем вызывать функцию не по имени, а через ее указатель.

Если функция `myfunc()` не перегружена, она существует в одном экземпляре, и компи­лятор без труда вычисляет ее адрес. Однако, если функция `myfunc()` перегружена, воз­никает вопрос, каким образом компилятор может вычислить ее указатель? Ответ зави­сит от того, как объявлен указатель `р`.

```cpp
int myfunc(int);
int myfunc(int, int);

int main()
{
    int (*fp)(int, int);
    
    fp = myfunc;

    std::cout << fp(5, 3) << std::endl; // 15

    return 0;
}

int myfunc(int a)
{
    return a;
}

int myfunc(int a, int b)
{
    return a * b;
}
```

### 43. Определение системы и три примера систем

**Система** - множество взаимосвязанных и взаимодействующих объектов для решения одной или множества задач (достижения одной или множества целей).

Примеры систем:

- Солнечная систем.
- растение.
- живой организм.
- автомобиль.
- компьютер.
- разговорный язык.
- математический язык.
- нотные записи.
- футбольный клуб,
- Аврора

### 44.  Перегрузка бинарных операторов

```cpp
Vec operator+(const Vec& v2) const
{
    return Vec(x + v2.x, y + v2.y);
}
Vec operator+=(const Vec& v2)
{
    x += v2.x;
    y += v2.y;

    return *this;
}

Vec vec1(11, 12);
Vec vec2(5, -9);

Vec vec3 = vec1 + vec2;
```

### 45.  При наследовании одного класса другим, когда вызываются конструкторы классов? Когда вызываются их деструкторы?

В C ++ конструкторы и деструкторы не наследуются. Однако они вызываются, когда дочерний класс инициализирует свой объект. Конструкторы вызываются один за другим иерархически, начиная с базового класса и заканчивая последним производным классом.

Деструкторы вызываются в обратном порядке.

46. Полиморфизм.
47. Параметризированные конструкторы.
48. Программа – система.
50. Перегрузка оператора индексации массивов [ ]
51. Присвоение объектов.
52. Приведение типов.
53. Перегрузка функций.
54. Перегрузка унарных операторов.
55. Структура. Назначение и синтаксис описания.
56. Операторы new и delete.
57. Сигналы и обработчики.
58. Форматированный ввод-вывод данных.
59. Что такое родовой класс и какова его основная форма?
60. Что происходит, когда открытые члены базового класса наследуются как
открытые? Что происходит, когда они наследуются как закрытые?
61. Чисто виртуальные функции и абстрактные классы.
62. Что такое родовая функция и какова ее основная форма?
63. Что такое встраиваемая функция? В чем ее преимущества и недостатки?
64. Чем действие дружественной оператор-функции отличается от действия
оператор-функции — члена класса?
65. Что такое объект?
66. Что происходит с защищенным членом класса, когда класс наследуется
как открытый? Что происходит, когда он наследуется как закрытый?
67. Управление доступом к элементам класса.
68. Указатели и ссылки на объект.
69. Указатель на объект производного класса
70. Управление доступом при наследовании.
71. Указатель this.
72. Шаблон класса.
73. Шаблон функции.